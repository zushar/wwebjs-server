{"version":3,"sources":["../../src/wwebjs/connect.service.ts"],"sourcesContent":["// connect.service.ts\nimport { Inject, Injectable, Logger } from '@nestjs/common';\nimport Redis from 'ioredis';\nimport { ClientFactoryService } from './client-factory.service';\nimport { Client } from 'whatsapp-web.js';\nimport { REDIS_CLIENT } from '../redis/redis.module';\nimport { ClientType, ClientMeta, ClientState } from './client-meta.type';\nimport * as fs from 'fs';\n\n@Injectable()\nexport class ConnectService {\n  private readonly logger = new Logger(ConnectService.name);\n  private clients: Map<string, ClientState> = new Map();\n\n  constructor(\n    @Inject(REDIS_CLIENT) private readonly redisClient: Redis,\n    private readonly clientFactory: ClientFactoryService,\n  ) {}\n\n  private getRedisKey(phoneNumber: string): string {\n    return `wa-client:${phoneNumber}`;\n  }\n  /**\n   * Retrieves the client metadata from Redis.\n   * Returns null if not found.\n   */\n  async getClientMeta(phoneNumber: string): Promise<ClientMeta | null> {\n    const redisKey = this.getRedisKey(phoneNumber);\n    const data = await this.redisClient.get(redisKey);\n    if (!data) {\n      this.logger.warn(\n        `No Redis record found for ${phoneNumber} during metadata retrieval.`,\n      );\n      return null;\n    }\n    try {\n      const parsedData = JSON.parse(data) as ClientMeta;\n      this.logger.log(\n        `Client metadata retrieved from Redis for ${phoneNumber}: ${JSON.stringify(\n          parsedData,\n        )}`,\n      );\n      return parsedData;\n    } catch (e) {\n      this.logger.error(\n        `Failed to parse Redis data for ${phoneNumber} during metadata retrieval: ${data}`,\n        e,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves the active WhatsApp client instance.\n   * Throws an error if the client is not found or not ready.\n   */\n  getClient(phoneNumber: string): {\n    client: Client;\n    ready: boolean;\n    verified: boolean;\n  } {\n    const clientData = this.clients.get(phoneNumber);\n    if (!clientData) {\n      const errorMsg = `Client for phone number ${phoneNumber} not found in memory`;\n      this.logger.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    if (!clientData.ready) {\n      const errorMsg = `Client for phone number ${phoneNumber} is not ready`;\n      this.logger.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    this.logger.log(`Client ${phoneNumber} found in memory and ready.`);\n    return {\n      client: clientData.client,\n      ready: clientData.ready,\n      verified: clientData.verified,\n    };\n  }\n\n  /**\n   * Converts a ClientState to a ClientMeta for Redis storage.\n   */\n  private toClientMeta(state: ClientState): ClientMeta {\n    return {\n      id: state.id,\n      verified: state.verified,\n      type: state.clientType,\n      lastActive: state.lastActive,\n    };\n  }\n\n  /**\n   * Creates (or reinitializes) a WhatsApp client using LocalAuth and returns a pairingCode if needed.\n   * Stores verification status in Redis.\n   */\n  async createVerificationCode(\n    phoneNumber: string,\n    clientType: ClientType,\n    verifid = false,\n  ): Promise<{ clientId: string; pairingCode?: string; message?: string }> {\n    const clientId = phoneNumber;\n    this.logger.log(`Initializing WhatsApp client for: ${phoneNumber}`);\n    const clientData: ClientState | undefined = this.clients.get(clientId);\n\n    if (clientData && !clientData.verified) {\n      this.logger.warn(\n        `Client ${clientId} already exists but is not verified.`,\n      );\n      return {\n        clientId: clientData.id,\n        message: 'Client already exists but not verified',\n      };\n    } else if (clientData && clientData.verified) {\n      this.logger.warn(\n        `Client ${clientId} already exists and is verified. Reinitializing...`,\n      );\n      return {\n        clientId: clientData.id,\n        message: 'Client already exists and is verified',\n      };\n    }\n\n    const client = this.clientFactory.createClient(phoneNumber);\n    const newClient: ClientState = {\n      id: clientId,\n      client: client,\n      ready: false,\n      verified: verifid,\n      lastActive: Date.now(),\n      clientType: clientType,\n    };\n    this.clients.set(clientId, newClient);\n\n    return new Promise<{\n      clientId: string;\n      pairingCode?: string;\n      message?: string;\n    }>((resolve, reject) => {\n      let resolved = false;\n      let pairingCodeRequested = false;\n\n      const timeout = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          this.logger.error(\n            `Timed out waiting for client event (ready/qr) for ${phoneNumber}`,\n          );\n          this.clients.delete(clientId);\n          client\n            .destroy()\n            .catch((e) =>\n              this.logger.error(\n                `Error destroying client on timeout for ${phoneNumber}:`,\n                e,\n              ),\n            );\n          reject(new Error('Timed out waiting for client connection'));\n        }\n      }, 60000);\n\n      client.on('loading_screen', (percent, message) => {\n        this.logger.log(\n          `WhatsApp loading [${clientId}]: ${percent}% - ${message || 'Loading...'}`,\n        );\n      });\n\n      client.on('ready', async () => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          this.logger.log(`Client ready for ${phoneNumber}`);\n          newClient.ready = true;\n          newClient.verified = true;\n          newClient.lastActive = Date.now();\n          this.clients.set(clientId, newClient);\n\n          await this.redisClient.set(\n            this.getRedisKey(clientId),\n            JSON.stringify(this.toClientMeta(newClient)),\n          );\n          this.logger.log(`Stored verified status in Redis for ${phoneNumber}`);\n          resolve({ clientId, message: 'Client is ready' });\n        } else {\n          this.logger.warn(\n            `'ready' event received for ${phoneNumber} after promise was already resolved.`,\n          );\n        }\n      });\n\n      client.on('qr', (_qr: string) => {\n        if (resolved || pairingCodeRequested) {\n          this.logger.debug(\n            `Ignoring extra QR event for ${phoneNumber} (resolved: ${resolved}, requested: ${pairingCodeRequested}).`,\n          );\n          return;\n        }\n        pairingCodeRequested = true;\n        newClient.ready = true;\n        newClient.verified = false;\n        this.clients.set(clientId, newClient);\n\n        this.logger.log(\n          `QR received for ${phoneNumber}, requesting pairing code...`,\n        );\n        void client\n          .requestPairingCode(phoneNumber)\n          .then(async (pairingCode: string) => {\n            this.logger.log(\n              `Pairing code received for ${phoneNumber}: ${pairingCode}`,\n            );\n            await this.redisClient.set(\n              this.getRedisKey(clientId),\n              JSON.stringify(this.toClientMeta(newClient)),\n            );\n            this.logger.log(\n              `Stored unverified status in Redis for ${phoneNumber}`,\n            );\n            if (!resolved) {\n              resolved = true;\n              clearTimeout(timeout);\n              resolve({ clientId, pairingCode });\n            }\n          })\n          .catch((error: unknown) => {\n            this.logger.error(\n              `Failed to get pairing code for ${phoneNumber}:`,\n              error,\n            );\n            if (!resolved) {\n              resolved = true;\n              clearTimeout(timeout);\n              this.clients.delete(clientId);\n              client\n                .destroy()\n                .catch((e) =>\n                  this.logger.error(\n                    `Error destroying client on pairing code failure for ${phoneNumber}:`,\n                    e,\n                  ),\n                );\n              reject(error instanceof Error ? error : new Error(String(error)));\n            }\n          });\n      });\n\n      client.on('auth_failure', (error: unknown) => {\n        this.logger.error(\n          `Authentication failure for ${phoneNumber}: ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        );\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          this.clients.delete(clientId);\n          client\n            .destroy()\n            .catch((e) =>\n              this.logger.error(\n                `Error destroying client on auth failure for ${phoneNumber}:`,\n                e,\n              ),\n            );\n          reject(\n            new Error(\n              'Authentication failure: ' +\n                (error instanceof Error ? error.message : String(error)),\n            ),\n          );\n        }\n      });\n\n      client.on('disconnected', (reason) => {\n        this.logger.warn(\n          `Client ${phoneNumber} disconnected: ${reason}. Removing from active clients.`,\n        );\n        this.clients.delete(clientId);\n        client\n          .destroy()\n          .catch((e) =>\n            this.logger.error(\n              `Error destroying client on disconnect for ${phoneNumber}:`,\n              e,\n            ),\n          );\n        this.redisClient\n          .del(this.getRedisKey(clientId))\n          .catch((e) =>\n            this.logger.error(\n              `Error deleting Redis entry for ${phoneNumber} on disconnect:`,\n              e,\n            ),\n          );\n        const authPath = '../../wwebjs_auth/session-' + phoneNumber;\n        fs.rm(authPath, { recursive: true, force: true }, (err) => {\n          if (err) {\n            this.logger.error(\n              `Error deleting auth files for ${phoneNumber}:`,\n              err,\n            );\n          } else {\n            this.logger.log(\n              `Auth files deleted for ${phoneNumber} successfully.`,\n            );\n          }\n        });\n      });\n\n      this.logger.log(`Starting client initialization for ${phoneNumber}...`);\n      client.initialize().catch((error) => {\n        this.logger.error(\n          `Failed to initialize client for ${phoneNumber}:`,\n          error,\n        );\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          this.clients.delete(clientId);\n          reject(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n    });\n  }\n\n  /**\n   * Verifies the pairing code provided by the end user by updating Redis.\n   * Note: This assumes the 'ready' event will fire on the client instance\n   * after successful pairing, which will handle the final verification state.\n   * This method primarily confirms the user action.\n   */\n  async verifyCode(phoneNumber: string): Promise<{ message: string }> {\n    const clientId = phoneNumber;\n    this.logger.log(`Processing verification for phoneNumber: ${phoneNumber}`);\n\n    const connection = this.clients.get(clientId);\n    if (!connection) {\n      const errorMsg = `Client for phone number ${phoneNumber} not found in memory during verification. It might have disconnected.`;\n      this.logger.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n\n    if (!connection.ready) {\n      const errorMsg = `Client ${phoneNumber} is not ready for verification.`;\n      this.logger.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n\n    connection.verified = true;\n    await this.redisClient.set(\n      this.getRedisKey(clientId),\n      JSON.stringify(this.toClientMeta(connection)),\n    );\n\n    this.logger.log(\n      `Client ${phoneNumber} marked as verified in Redis and memory. Waiting for 'ready' event for final confirmation.`,\n    );\n    return { message: 'Verification processed. Client should become ready.' };\n  }\n\n  /**\n   * Checks if a client associated with the phone number is verified in Redis.\n   */\n  async isClientVerified(phoneNumber: string): Promise<boolean> {\n    const redisKey = this.getRedisKey(phoneNumber);\n    const data = await this.redisClient.get(redisKey);\n    if (!data) {\n      this.logger.warn(\n        `No Redis record found for ${phoneNumber} during verification check.`,\n      );\n      return false;\n    }\n    try {\n      const parsedData = JSON.parse(data) as ClientMeta;\n      return parsedData.verified;\n    } catch (e) {\n      this.logger.error(\n        `Failed to parse Redis data for ${phoneNumber} during verification check: ${data}`,\n        e,\n      );\n      return false;\n    }\n  }\n}\n"],"names":["ConnectService","getRedisKey","phoneNumber","getClientMeta","redisKey","data","redisClient","get","logger","warn","parsedData","JSON","parse","log","stringify","e","error","getClient","clientData","clients","errorMsg","Error","ready","client","verified","toClientMeta","state","id","type","clientType","lastActive","createVerificationCode","verifid","clientId","message","clientFactory","createClient","newClient","Date","now","set","Promise","resolve","reject","resolved","pairingCodeRequested","timeout","setTimeout","delete","destroy","catch","on","percent","clearTimeout","_qr","debug","requestPairingCode","then","pairingCode","String","reason","del","authPath","fs","rm","recursive","force","err","initialize","verifyCode","connection","isClientVerified","constructor","Logger","name","Map"],"mappings":"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"}